# 阶段2：内存限制+LRU淘汰策略
## 目标
- 支持设置最大内存上限，避免缓存OOM；
- 实现LRU淘汰策略，优先淘汰最久未使用的key；
- 保持高并发性能，淘汰逻辑不影响读写效率。

## 技术选型
1. LRU实现：双向链表（`container/list`）+ 哈希表
    - 原因：双向链表支持O(1)移动/删除节点，哈希表支持O(1)查找节点，组合后LRU的所有操作（访问、添加、淘汰）都是O(1)时间复杂度；
    - 替代方案：`github.com/hashicorp/golang-lru`（成熟库），但选择自研是为了沉淀实现经验。
2. 配置模式：建造者模式（Option）
    - 原因：后续会添加更多配置（如过期时间、自定义淘汰策略），建造者模式可避免函数参数过多，保持API简洁。

## 核心逻辑
1. Set流程：
    - 计算新条目的内存大小；
    - 若key已存在，先删除旧条目并减去其大小；
    - 若新增后超内存上限，循环调用LRU.Evict()淘汰key，直到内存足够；
    - 存储新条目并更新淘汰策略。
2. Get流程：
    - 查找key，若存在则更新访问时间和LRU链表（移到队尾）。

## 踩坑记录
1. 淘汰时未同步删除缓存数据：导致LRU淘汰了key，但缓存中仍存在该key，后续Get时又会把它加入LRU，出现“淘汰无效”；
    - 解决：淘汰key时，同时从`data` map中删除对应的条目。
2. 高并发下LRU链表竞争：初期未加锁，导致链表节点操作panic；
    - 解决：LRU的所有方法都在缓存的读写锁保护下执行（缓存的Set/Get/Delete已加锁，LRU操作无需额外加锁）。

## 性能测试结果
| 测试场景                | QPS  | 内存占用（10w条数据） | 淘汰命中率 |
|-------------------------|------|-----------------------|------------|
| 无内存限制（阶段1）     | 12w/s| 80MB                  | -          |
| 内存限制10MB（阶段2）   | 11.5w/s | 稳定在10MB左右       | 85%        |
- 结论：添加LRU淘汰后，性能仅下降4%，内存控制精准，满足预期。

## 下一步计划
- 阶段3：实现过期key删除功能（惰性删除+定时扫描）；
- 优化：支持自定义内存大小计算函数，支持淘汰策略动态切换。